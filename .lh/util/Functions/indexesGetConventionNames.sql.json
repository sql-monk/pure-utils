{
    "sourceFile": "util/Functions/indexesGetConventionNames.sql",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1758022338805,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758024321038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,28 @@\n+/*\r\n+# Description\r\n+Генерує стандартизовані назви індексів відповідно до конвенцій найменування.\r\n+Функція аналізує існуючі індекси і пропонує нові назви за встановленими стандартами.\r\n+\r\n+# Parameters\r\n+@object NVARCHAR(128) = NULL - Назва таблиці для генерації назв індексів (NULL = усі таблиці)\r\n+@index NVARCHAR(128) = NULL - Назва конкретного індексу (NULL = усі індекси)\r\n+\r\n+# Returns\r\n+TABLE - Повертає таблицю з колонками:\r\n+- SchemaName NVARCHAR(128) - Назва схеми\r\n+- TableName NVARCHAR(128) - Назва таблиці\r\n+- IndexName NVARCHAR(128) - Поточна назва індексу\r\n+- NewIndexName NVARCHAR(128) - Рекомендована назва згідно конвенцій\r\n+- IndexType NVARCHAR(60) - Тип індексу\r\n+\r\n+# Usage\r\n+-- Отримати рекомендовані назви для всіх індексів конкретної таблиці\r\n+SELECT * FROM util.indexesGetConventionNames('myTable', NULL);\r\n+\r\n+-- Отримати рекомендовану назву для конкретного індексу\r\n+SELECT * FROM util.indexesGetConventionNames('myTable', 'myIndex');\r\n+*/\r\n CREATE FUNCTION util.indexesGetConventionNames(@object NVARCHAR(128) = NULL, @index NVARCHAR(128) = NULL)\r\n RETURNS TABLE\r\n AS\r\n RETURN(\r\n"
                }
            ],
            "date": 1758022338805,
            "name": "Commit-0",
            "content": "CREATE FUNCTION util.indexesGetConventionNames(@object NVARCHAR(128) = NULL, @index NVARCHAR(128) = NULL)\r\nRETURNS TABLE\r\nAS\r\nRETURN(\r\n    WITH IndexInfo AS (\r\n        SELECT\r\n            s.name AS SchemaName,\r\n            t.name AS TableName,\r\n            i.name AS IndexName,\r\n            i.object_id,\r\n            i.index_id,\r\n            i.type_desc,\r\n            i.is_unique,\r\n            i.has_filter,\r\n            i.filter_definition,\r\n            i.is_padded,\r\n            i.is_hypothetical,\r\n            i.data_space_id,\r\n            ds.type_desc AS data_space_type,\r\n            CASE WHEN kc.type = 'PK' THEN 1 ELSE 0 END AS IsPrimaryKey\r\n        FROM sys.indexes i  (NOLOCK)\r\n            INNER JOIN sys.tables t   (NOLOCK) ON i.object_id = t.object_id\r\n            INNER JOIN sys.schemas s   (NOLOCK) ON t.schema_id = s.schema_id\r\n            LEFT JOIN sys.data_spaces ds (NOLOCK) ON i.data_space_id = ds.data_space_id\r\n            LEFT JOIN sys.key_constraints kc (NOLOCK) ON i.object_id = kc.parent_object_id AND i.index_id = kc.unique_index_id AND kc.type = 'PK'\r\n        WHERE \r\n            (@object IS NULL OR i.object_id = ISNULL(TRY_CONVERT(INT, @object), OBJECT_ID(@object)))\r\n            AND (@index IS NULL OR i.name = @index)\r\n            AND i.is_hypothetical = 0 -- skip hypothetical indexes\r\n            AND i.type_desc <> 'HEAP' -- skip heaps\r\n            AND i.name IS NOT NULL -- skip heap indexes\r\n    )\r\n    , IndexColumns AS (\r\n        SELECT\r\n            ic.object_id,\r\n            ic.index_id,\r\n            STRING_AGG(\r\n                LEFT(c.name + CASE WHEN ic.is_descending_key = 1 THEN '_D' ELSE '' END, 32), '_'\r\n            ) WITHIN GROUP (ORDER BY ic.index_column_id) AS KeyColumns\r\n        FROM sys.index_columns ic (NOLOCK)\r\n            INNER JOIN sys.columns c (NOLOCK) ON ic.object_id = c.object_id AND ic.column_id = c.column_id\r\n        WHERE ic.is_included_column = 0\r\n        GROUP BY ic.object_id, ic.index_id\r\n    )\r\n    , IndexInclude AS (\r\n        SELECT\r\n            ic.object_id,\r\n            ic.index_id,\r\n            MAX(CASE WHEN ic.is_included_column = 1 THEN 1 ELSE 0 END) AS HasInclude\r\n        FROM sys.index_columns ic (NOLOCK)\r\n        GROUP BY ic.object_id, ic.index_id\r\n    )\r\n    , ProposedIndexNames AS (\r\n        SELECT\r\n            ii.object_id,\r\n            ii.index_id,\r\n            ii.SchemaName,\r\n            ii.TableName,\r\n            ii.IndexName AS CurrentIndexName,\r\n            CASE \r\n                WHEN ii.IsPrimaryKey = 1 THEN CONCAT('PK_', ii.TableName, '_', LEFT(ISNULL(ic.KeyColumns, ''), 100))\r\n                WHEN ii.type_desc = 'CLUSTERED' THEN CONCAT('CI_', LEFT(ISNULL(ic.KeyColumns, ''), 100))\r\n                WHEN ii.type_desc = 'CLUSTERED COLUMNSTORE' THEN 'CCSI'\r\n                WHEN ii.type_desc = 'NONCLUSTERED' AND ii.data_space_type = 'COLUMNSTORE' THEN CONCAT('CS_', LEFT(ISNULL(ic.KeyColumns, ''), 100))\r\n                WHEN ii.type_desc = 'NONCLUSTERED' THEN CONCAT('IX_', LEFT(ISNULL(ic.KeyColumns, ''), 100))\r\n                ELSE CONCAT('IX_',ii.type_desc COLLATE DATABASE_DEFAULT, '_', LEFT(ISNULL(ic.KeyColumns, ''), 100))\r\n            END AS BaseIndexName,\r\n            CASE WHEN ii.IsPrimaryKey = 1 OR ii.type_desc = 'CLUSTERED COLUMNSTORE' THEN '' ELSE\r\n                CONCAT(\r\n                    CASE WHEN inc.HasInclude = 1 THEN '_INC' ELSE '' END,\r\n                    CASE WHEN ii.has_filter = 1 THEN '_FLT' ELSE '' END,\r\n                    CASE WHEN ii.is_unique = 1 THEN '_UQ' ELSE '' END,\r\n                    CASE WHEN ii.data_space_type = 'PARTITION_SCHEME' THEN '_P' ELSE '' END\r\n                )\r\n            END AS IndexSuffix\r\n        FROM IndexInfo ii\r\n        LEFT JOIN IndexColumns ic ON ii.object_id = ic.object_id AND ii.index_id = ic.index_id\r\n        LEFT JOIN IndexInclude inc ON ii.object_id = inc.object_id AND ii.index_id = inc.index_id\r\n    )\r\n    , FinalIndexNames AS (\r\n        SELECT \r\n            pin.object_id,\r\n            pin.index_id,\r\n            pin.SchemaName,\r\n            pin.TableName,\r\n            pin.CurrentIndexName,\r\n            pin.BaseIndexName + pin.IndexSuffix AS ProposedName,\r\n            -- ��� ���������� ���� �������� ��� �������, ��� �������� ������ �����\r\n            CASE \r\n                WHEN ROW_NUMBER() OVER (PARTITION BY pin.BaseIndexName + pin.IndexSuffix ORDER BY pin.index_id) = 1 \r\n                    AND COUNT(*) OVER (PARTITION BY pin.BaseIndexName + pin.IndexSuffix) = 1 \r\n                THEN ''\r\n                ELSE CAST(ROW_NUMBER() OVER (PARTITION BY pin.BaseIndexName + pin.IndexSuffix ORDER BY pin.index_id) AS NVARCHAR(10))\r\n            END AS NumberSuffix\r\n        FROM ProposedIndexNames pin\r\n    )\r\n    SELECT\r\n        QUOTENAME(fin.SchemaName) + '.' + QUOTENAME(fin.TableName) + '.' + QUOTENAME(fin.CurrentIndexName) AS currentName,\r\n        QUOTENAME(fin.SchemaName) + '.' + QUOTENAME(fin.TableName) + '.' + QUOTENAME(fin.ProposedName + fin.NumberSuffix) AS newName\r\n    FROM FinalIndexNames fin\r\n);"
        }
    ]
}