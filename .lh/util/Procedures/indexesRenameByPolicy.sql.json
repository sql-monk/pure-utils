{
    "sourceFile": "util/Procedures/indexesRenameByPolicy.sql",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1757954016344,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1757954316820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n CREATE PROCEDURE [dbo].[indexesRenameByPolicy]\r\n \t@tableName sysname = NULL,\r\n-\t@indexName sysname = NULL\r\n+\t@indexName sysname = NULL,\r\n+\t@output tinyint = 1\r\n AS\r\n BEGIN\r\n \tSET NOCOUNT ON;\r\n \r\n@@ -13,9 +14,9 @@\n \t\tOPEN mcur;\r\n \t\tFETCH NEXT FROM mcur INTO @t;\r\n \t\tWHILE @@FETCH_STATUS = 0\r\n \t\tBEGIN\r\n-\t\t\tEXEC dbo.RenameIndexesByPolicy @t;\r\n+\t\t\tEXEC dbo.indexesRenameByPolicy @t, NULL, @output;\r\n \t\t\tFETCH NEXT FROM mcur INTO @t;\r\n \t\tEND\r\n \t\tCLOSE mcur\r\n \t\tDEALLOCATE mcur\r\n@@ -114,25 +115,88 @@\n \t\t\t'EXEC sp_rename ''',\r\n \t\t\t@tableName, '.', QUOTENAME(fin.CurrentIndexName), ''', ''',\r\n \t\t\tfin.ProposedName + fin.NumberSuffix,\r\n \t\t\t''', ''INDEX'';'\r\n-\t\t) AS RenameCommand\r\n+\t\t) AS RenameCommand,\r\n+\t\tii.SchemaName + '.' + ii.TableName AS FullTableName,\r\n+\t\tfin.CurrentIndexName,\r\n+\t\tfin.ProposedName + fin.NumberSuffix AS NewIndexName,\r\n+\t\tii.type_desc AS IndexType,\r\n+\t\tii.is_unique,\r\n+\t\tii.has_filter\r\n \tINTO #RenameCommands\r\n \tFROM FinalIndexNames fin\r\n+\tINNER JOIN IndexInfo ii ON fin.object_id = ii.object_id AND fin.index_id = ii.index_id\r\n \tWHERE fin.CurrentIndexName <> fin.ProposedName + fin.NumberSuffix; -- Перейменовуємо тільки ті, що відрізняються\r\n \r\n-\tDECLARE @cmd NVARCHAR(MAX);\r\n-\tDECLARE rename_cursor CURSOR LOCAL FAST_FORWARD FOR\r\n-\t\tSELECT RenameCommand FROM #RenameCommands;\r\n+\t-- Обробка залежно від @output параметру\r\n+\t-- Біт 1 (1) - PRINT\r\n+\tIF (@output & 1) = 1\r\n+\tBEGIN\r\n+\t\tDECLARE @printCmd NVARCHAR(MAX);\r\n+\t\tDECLARE print_cursor CURSOR LOCAL FAST_FORWARD FOR\r\n+\t\t\tSELECT RenameCommand FROM #RenameCommands;\r\n+\t\t\r\n+\t\tOPEN print_cursor;\r\n+\t\tFETCH NEXT FROM print_cursor INTO @printCmd;\r\n+\t\tWHILE @@FETCH_STATUS = 0\r\n+\t\tBEGIN\r\n+\t\t\tPRINT @printCmd;\r\n+\t\t\tFETCH NEXT FROM print_cursor INTO @printCmd;\r\n+\t\tEND\r\n+\t\tCLOSE print_cursor;\r\n+\t\tDEALLOCATE print_cursor;\r\n+\tEND\r\n \r\n-\tOPEN rename_cursor;\r\n-\tFETCH NEXT FROM rename_cursor INTO @cmd;\r\n-\tWHILE @@FETCH_STATUS = 0\r\n+\t-- Біт 2 (2) - Rowset\r\n+\tIF (@output & 2) = 2\r\n \tBEGIN\r\n-\t\tPRINT @cmd; -- Для відладки - показуємо команду перед виконанням\r\n-\t\tEXEC sp_executesql @cmd;\r\n+\t\tSELECT \r\n+\t\t\tFullTableName,\r\n+\t\t\tCurrentIndexName,\r\n+\t\t\tNewIndexName,\r\n+\t\t\tIndexType,\r\n+\t\t\tis_unique,\r\n+\t\t\thas_filter,\r\n+\t\t\tRenameCommand\r\n+\t\tFROM #RenameCommands\r\n+\t\tORDER BY FullTableName, CurrentIndexName;\r\n+\tEND\r\n+\r\n+\t-- Біт 3 (4) - Single row (XML)\r\n+\tIF (@output & 4) = 4\r\n+\tBEGIN\r\n+\t\tSELECT (\r\n+\t\t\tSELECT \r\n+\t\t\t\tFullTableName,\r\n+\t\t\t\tCurrentIndexName,\r\n+\t\t\t\tNewIndexName,\r\n+\t\t\t\tIndexType,\r\n+\t\t\t\tis_unique,\r\n+\t\t\t\thas_filter,\r\n+\t\t\t\tRenameCommand\r\n+\t\t\tFROM #RenameCommands\r\n+\t\t\tORDER BY FullTableName, CurrentIndexName\r\n+\t\t\tFOR XML PATH('Index'), ROOT('IndexRenames')\r\n+\t\t) AS IndexRenamesXML;\r\n+\tEND\r\n+\r\n+\t-- Біт 4 (8) - Execute\r\n+\tIF (@output & 8) = 8\r\n+\tBEGIN\r\n+\t\tDECLARE @cmd NVARCHAR(MAX);\r\n+\t\tDECLARE rename_cursor CURSOR LOCAL FAST_FORWARD FOR\r\n+\t\t\tSELECT RenameCommand FROM #RenameCommands;\r\n+\r\n+\t\tOPEN rename_cursor;\r\n \t\tFETCH NEXT FROM rename_cursor INTO @cmd;\r\n+\t\tWHILE @@FETCH_STATUS = 0\r\n+\t\tBEGIN\r\n+\t\t\tEXEC sp_executesql @cmd;\r\n+\t\t\tFETCH NEXT FROM rename_cursor INTO @cmd;\r\n+\t\tEND\r\n+\t\tCLOSE rename_cursor;\r\n+\t\tDEALLOCATE rename_cursor;\r\n \tEND\r\n-\tCLOSE rename_cursor;\r\n-\tDEALLOCATE rename_cursor;\r\n+\r\n \tDROP TABLE #RenameCommands;\r\n END;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1757954781506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n \t\tOPEN mcur;\r\n \t\tFETCH NEXT FROM mcur INTO @t;\r\n \t\tWHILE @@FETCH_STATUS = 0\r\n \t\tBEGIN\r\n-\t\t\tEXEC dbo.indexesRenameByPolicy @t, NULL, @output;\r\n+\t\t\tEXEC dbo.RenameIndexesByPolicy @t;\r\n \t\t\tFETCH NEXT FROM mcur INTO @t;\r\n \t\tEND\r\n \t\tCLOSE mcur\r\n \t\tDEALLOCATE mcur\r\n@@ -115,88 +115,37 @@\n \t\t\t'EXEC sp_rename ''',\r\n \t\t\t@tableName, '.', QUOTENAME(fin.CurrentIndexName), ''', ''',\r\n \t\t\tfin.ProposedName + fin.NumberSuffix,\r\n \t\t\t''', ''INDEX'';'\r\n-\t\t) AS RenameCommand,\r\n-\t\tii.SchemaName + '.' + ii.TableName AS FullTableName,\r\n-\t\tfin.CurrentIndexName,\r\n-\t\tfin.ProposedName + fin.NumberSuffix AS NewIndexName,\r\n-\t\tii.type_desc AS IndexType,\r\n-\t\tii.is_unique,\r\n-\t\tii.has_filter\r\n+\t\t) AS RenameCommand\r\n \tINTO #RenameCommands\r\n \tFROM FinalIndexNames fin\r\n-\tINNER JOIN IndexInfo ii ON fin.object_id = ii.object_id AND fin.index_id = ii.index_id\r\n \tWHERE fin.CurrentIndexName <> fin.ProposedName + fin.NumberSuffix; -- Перейменовуємо тільки ті, що відрізняються\r\n+  if(@output | 2 = 2)\r\n+  BEGIN\r\n+    SELECT RenameCommand FROM #RenameCommands;\r\n+  END\r\n \r\n-\t-- Обробка залежно від @output параметру\r\n-\t-- Біт 1 (1) - PRINT\r\n-\tIF (@output & 1) = 1\r\n-\tBEGIN\r\n-\t\tDECLARE @printCmd NVARCHAR(MAX);\r\n-\t\tDECLARE print_cursor CURSOR LOCAL FAST_FORWARD FOR\r\n-\t\t\tSELECT RenameCommand FROM #RenameCommands;\r\n-\t\t\r\n-\t\tOPEN print_cursor;\r\n-\t\tFETCH NEXT FROM print_cursor INTO @printCmd;\r\n-\t\tWHILE @@FETCH_STATUS = 0\r\n-\t\tBEGIN\r\n-\t\t\tPRINT @printCmd;\r\n-\t\t\tFETCH NEXT FROM print_cursor INTO @printCmd;\r\n-\t\tEND\r\n-\t\tCLOSE print_cursor;\r\n-\t\tDEALLOCATE print_cursor;\r\n-\tEND\r\n+  if(@output | 2 = 4)\r\n+  BEGIN\r\n+    SELECT CONVERT(XML, STRING_AGG(RenameCommand, CHAR(13) + CHAR(10)))  AllCommands\r\n+    FROM #RenameCommands;  \r\n+  END\r\n \r\n-\t-- Біт 2 (2) - Rowset\r\n-\tIF (@output & 2) = 2\r\n-\tBEGIN\r\n-\t\tSELECT \r\n-\t\t\tFullTableName,\r\n-\t\t\tCurrentIndexName,\r\n-\t\t\tNewIndexName,\r\n-\t\t\tIndexType,\r\n-\t\t\tis_unique,\r\n-\t\t\thas_filter,\r\n-\t\t\tRenameCommand\r\n-\t\tFROM #RenameCommands\r\n-\t\tORDER BY FullTableName, CurrentIndexName;\r\n-\tEND\r\n+  if(@output | 8 = 8) \r\n+  BEGIN\r\n+    DECLARE @cmd NVARCHAR(MAX);\r\n+    DECLARE rename_cursor CURSOR LOCAL FAST_FORWARD FOR\r\n+      SELECT RenameCommand FROM #RenameCommands;\r\n \r\n-\t-- Біт 3 (4) - Single row (XML)\r\n-\tIF (@output & 4) = 4\r\n-\tBEGIN\r\n-\t\tSELECT (\r\n-\t\t\tSELECT \r\n-\t\t\t\tFullTableName,\r\n-\t\t\t\tCurrentIndexName,\r\n-\t\t\t\tNewIndexName,\r\n-\t\t\t\tIndexType,\r\n-\t\t\t\tis_unique,\r\n-\t\t\t\thas_filter,\r\n-\t\t\t\tRenameCommand\r\n-\t\t\tFROM #RenameCommands\r\n-\t\t\tORDER BY FullTableName, CurrentIndexName\r\n-\t\t\tFOR XML PATH('Index'), ROOT('IndexRenames')\r\n-\t\t) AS IndexRenamesXML;\r\n+    OPEN rename_cursor;\r\n+    FETCH NEXT FROM rename_cursor INTO @cmd;\r\n+    WHILE @@FETCH_STATUS = 0\r\n+    BEGIN\r\n+      IF (@output | 1 = 1) PRINT @cmd;\r\n+      IF (@output | 8 = 8) EXEC sp_executesql @cmd;\r\n+      FETCH NEXT FROM rename_cursor INTO @cmd;\r\n+    END\r\n+    CLOSE rename_cursor;\r\n+    DEALLOCATE rename_cursor;\r\n \tEND\r\n-\r\n-\t-- Біт 4 (8) - Execute\r\n-\tIF (@output & 8) = 8\r\n-\tBEGIN\r\n-\t\tDECLARE @cmd NVARCHAR(MAX);\r\n-\t\tDECLARE rename_cursor CURSOR LOCAL FAST_FORWARD FOR\r\n-\t\t\tSELECT RenameCommand FROM #RenameCommands;\r\n-\r\n-\t\tOPEN rename_cursor;\r\n-\t\tFETCH NEXT FROM rename_cursor INTO @cmd;\r\n-\t\tWHILE @@FETCH_STATUS = 0\r\n-\t\tBEGIN\r\n-\t\t\tEXEC sp_executesql @cmd;\r\n-\t\t\tFETCH NEXT FROM rename_cursor INTO @cmd;\r\n-\t\tEND\r\n-\t\tCLOSE rename_cursor;\r\n-\t\tDEALLOCATE rename_cursor;\r\n-\tEND\r\n-\r\n-\tDROP TABLE #RenameCommands;\r\n END;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1757954788624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,10 +126,9 @@\n   END\r\n \r\n   if(@output | 2 = 4)\r\n   BEGIN\r\n-    SELECT CONVERT(XML, STRING_AGG(RenameCommand, CHAR(13) + CHAR(10)))  AllCommands\r\n-    FROM #RenameCommands;  \r\n+    SELECT CONVERT(XML, STRING_AGG(RenameCommand, CHAR(13) + CHAR(10))) AllCommands FROM #RenameCommands;  \r\n   END\r\n \r\n   if(@output | 8 = 8) \r\n   BEGIN\r\n"
                },
                {
                    "date": 1757955796490,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-CREATE PROCEDURE [dbo].[indexesRenameByPolicy]\r\n+CREATE PROCEDURE [util].[indexesRenameByPolicy]\r\n \t@tableName sysname = NULL,\r\n \t@indexName sysname = NULL,\r\n \t@output tinyint = 1\r\n AS\r\n@@ -119,30 +119,34 @@\n \t\t) AS RenameCommand\r\n \tINTO #RenameCommands\r\n \tFROM FinalIndexNames fin\r\n \tWHERE fin.CurrentIndexName <> fin.ProposedName + fin.NumberSuffix; -- Перейменовуємо тільки ті, що відрізняються\r\n-  if(@output | 2 = 2)\r\n+\t\r\n+\tDECLARE @commands NVARCHAR(max) = ''\r\n+  \r\n+\tIF (@output & (1 | 4) in (1, 4))\r\n+\tBEGIN\r\n+\t\tSELECT @commands += RenameCommand FROM #RenameCommands;\r\n+\t\tIF(@output & 1 = 1) PRINT @commands\r\n+\t\tIF(@output & 4 = 4) SELECT CONVERT(XML, @commands)\r\n+\tEND\r\n+\r\n+\tIF(@output & 2 = 2)\r\n   BEGIN\r\n     SELECT RenameCommand FROM #RenameCommands;\r\n   END\r\n \r\n-  if(@output | 2 = 4)\r\n+  if(@output & 8 = 8) \r\n   BEGIN\r\n-    SELECT CONVERT(XML, STRING_AGG(RenameCommand, CHAR(13) + CHAR(10))) AllCommands FROM #RenameCommands;  \r\n-  END\r\n-\r\n-  if(@output | 8 = 8) \r\n-  BEGIN\r\n     DECLARE @cmd NVARCHAR(MAX);\r\n     DECLARE rename_cursor CURSOR LOCAL FAST_FORWARD FOR\r\n       SELECT RenameCommand FROM #RenameCommands;\r\n \r\n     OPEN rename_cursor;\r\n     FETCH NEXT FROM rename_cursor INTO @cmd;\r\n     WHILE @@FETCH_STATUS = 0\r\n     BEGIN\r\n-      IF (@output | 1 = 1) PRINT @cmd;\r\n-      IF (@output | 8 = 8) EXEC sp_executesql @cmd;\r\n+      IF (@output & 8 = 8) EXEC sp_executesql @cmd;\r\n       FETCH NEXT FROM rename_cursor INTO @cmd;\r\n     END\r\n     CLOSE rename_cursor;\r\n     DEALLOCATE rename_cursor;\r\n"
                }
            ],
            "date": 1757954016344,
            "name": "Commit-0",
            "content": "CREATE PROCEDURE [dbo].[indexesRenameByPolicy]\r\n\t@tableName sysname = NULL,\r\n\t@indexName sysname = NULL\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @objectID INT = OBJECT_ID(@tableName);\r\n\tIF @objectID IS NULL\r\n\tBEGIN\r\n\t\tDECLARE @t NVARCHAR(128)\r\n\t\tDECLARE\t mcur CURSOR LOCAL STATIC FORWARD_ONLY READ_ONLY FOR SELECT CONCAT(OBJECT_SCHEMA_NAME(object_id),'.',name) FROM sys.tables WHERE is_ms_shipped = 0\r\n\t\tOPEN mcur;\r\n\t\tFETCH NEXT FROM mcur INTO @t;\r\n\t\tWHILE @@FETCH_STATUS = 0\r\n\t\tBEGIN\r\n\t\t\tEXEC dbo.RenameIndexesByPolicy @t;\r\n\t\t\tFETCH NEXT FROM mcur INTO @t;\r\n\t\tEND\r\n\t\tCLOSE mcur\r\n\t\tDEALLOCATE mcur\r\n\t\tRETURN;\r\n\tEND;\r\n\r\n\tWITH IndexInfo AS (\r\n\t\tSELECT\r\n\t\t\ts.name AS SchemaName,\r\n\t\t\tt.name AS TableName,\r\n\t\t\ti.name AS IndexName,\r\n\t\t\ti.object_id,\r\n\t\t\ti.index_id,\r\n\t\t\ti.type_desc,\r\n\t\t\ti.is_unique,\r\n\t\t\ti.has_filter,\r\n\t\t\ti.filter_definition,\r\n\t\t\ti.is_padded,\r\n\t\t\ti.is_hypothetical,\r\n\t\t\ti.data_space_id,\r\n\t\t\tds.type_desc AS data_space_type,\r\n\t\t\tCASE WHEN kc.type = 'PK' THEN 1 ELSE 0 END AS IsPrimaryKey\r\n\t\tFROM sys.indexes i\r\n\t\t\tINNER JOIN sys.tables t ON i.object_id = t.object_id\r\n\t\t\tINNER JOIN sys.schemas s ON t.schema_id = s.schema_id\r\n\t\t\tLEFT JOIN sys.data_spaces ds ON i.data_space_id = ds.data_space_id\r\n\t\t\tLEFT JOIN sys.key_constraints kc ON i.object_id = kc.parent_object_id AND i.index_id = kc.unique_index_id AND kc.type = 'PK'\r\n\t\tWHERE \r\n\t\t\tt.object_id = @objectID\r\n\t\t\tAND ISNULL(@indexName, i.name) = i.name\r\n\t\t\tAND i.is_hypothetical = 0 -- skip hypothetical indexes\r\n\t\t\tAND i.type_desc <> 'HEAP' -- skip heaps\r\n\t)\r\n\t, IndexColumns AS (\r\n\t\tSELECT\r\n\t\t\tic.object_id,\r\n\t\t\tic.index_id,\r\n\t\t\tSTRING_AGG(\r\n\t\t\t\tLEFT(c.name + CASE WHEN ic.is_descending_key = 1 THEN '_D' ELSE '' END, 32), '_'\r\n\t\t\t) WITHIN GROUP (ORDER BY ic.index_column_id) AS KeyColumns\r\n\t\tFROM sys.index_columns ic\r\n\t\t\tINNER JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id\r\n\t\tWHERE ic.is_included_column = 0\r\n\t\tGROUP BY ic.object_id, ic.index_id\r\n\t)\r\n\t, IndexInclude AS (\r\n\t\tSELECT\r\n\t\t\tic.object_id,\r\n\t\t\tic.index_id,\r\n\t\t\tMAX(CASE WHEN ic.is_included_column = 1 THEN 1 ELSE 0 END) AS HasInclude\r\n\t\tFROM sys.index_columns ic\r\n\t\tGROUP BY ic.object_id, ic.index_id\r\n\t)\r\n\t, ProposedIndexNames AS (\r\n\t\tSELECT\r\n\t\t\tii.object_id,\r\n\t\t\tii.index_id,\r\n\t\t\tii.IndexName AS CurrentIndexName,\r\n\t\t\tCASE \r\n\t\t\t\tWHEN ii.IsPrimaryKey = 1 THEN CONCAT('PK_', ii.TableName, '_', LEFT(ISNULL(ic.KeyColumns, ''), 100))\r\n\t\t\t\tWHEN ii.type_desc = 'CLUSTERED' THEN CONCAT('CI_', LEFT(ISNULL(ic.KeyColumns, ''), 100))\r\n\t\t\t\tWHEN ii.type_desc = 'CLUSTERED COLUMNSTORE' THEN 'CCSI'\r\n\t\t\t\tWHEN ii.type_desc = 'NONCLUSTERED' AND ii.data_space_type = 'COLUMNSTORE' THEN CONCAT('CS_', LEFT(ISNULL(ic.KeyColumns, ''), 100))\r\n\t\t\t\tWHEN ii.type_desc = 'NONCLUSTERED' THEN CONCAT('IX_', LEFT(ISNULL(ic.KeyColumns, ''), 100))\r\n\t\t\t\tELSE CONCAT('IX_',ii.type_desc COLLATE DATABASE_DEFAULT, '_', LEFT(ISNULL(ic.KeyColumns, ''), 100))\r\n\t\t\tEND AS BaseIndexName,\r\n\t\t\tCASE WHEN ii.IsPrimaryKey = 1 OR ii.type_desc = 'CLUSTERED COLUMNSTORE' THEN '' ELSE\r\n\t\t\t\tCONCAT(\r\n\t\t\t\t\tCASE WHEN inc.HasInclude = 1 THEN '_INC' ELSE '' END,\r\n\t\t\t\t\tCASE WHEN ii.has_filter = 1 THEN '_FLT' ELSE '' END,\r\n\t\t\t\t\tCASE WHEN ii.is_unique = 1 THEN '_UQ' ELSE '' END,\r\n\t\t\t\t\tCASE WHEN ii.data_space_type = 'PARTITION_SCHEME' THEN '_P' ELSE '' END\r\n\t\t\t\t)\r\n\t\t\tEND AS IndexSuffix\r\n\t\tFROM IndexInfo ii\r\n\t\tLEFT JOIN IndexColumns ic ON ii.object_id = ic.object_id AND ii.index_id = ic.index_id\r\n\t\tLEFT JOIN IndexInclude inc ON ii.object_id = inc.object_id AND ii.index_id = inc.index_id\r\n\t)\r\n\t, FinalIndexNames AS (\r\n\t\tSELECT \r\n\t\t\tpin.object_id,\r\n\t\t\tpin.index_id,\r\n\t\t\tpin.CurrentIndexName,\r\n\t\t\tpin.BaseIndexName + pin.IndexSuffix AS ProposedName,\r\n\t\t\t-- Для унікальних імен залишаємо без суфіксу, для дублікатів додаємо номер\r\n\t\t\tCASE \r\n\t\t\t\tWHEN ROW_NUMBER() OVER (PARTITION BY pin.BaseIndexName + pin.IndexSuffix ORDER BY pin.index_id) = 1 \r\n\t\t\t\t\tAND COUNT(*) OVER (PARTITION BY pin.BaseIndexName + pin.IndexSuffix) = 1 \r\n\t\t\t\tTHEN ''\r\n\t\t\t\tELSE CAST(ROW_NUMBER() OVER (PARTITION BY pin.BaseIndexName + pin.IndexSuffix ORDER BY pin.index_id) AS NVARCHAR(10))\r\n\t\t\tEND AS NumberSuffix\r\n\t\tFROM ProposedIndexNames pin\r\n\t)\r\n\tSELECT\r\n\t\tCONCAT(\r\n\t\t\t'EXEC sp_rename ''',\r\n\t\t\t@tableName, '.', QUOTENAME(fin.CurrentIndexName), ''', ''',\r\n\t\t\tfin.ProposedName + fin.NumberSuffix,\r\n\t\t\t''', ''INDEX'';'\r\n\t\t) AS RenameCommand\r\n\tINTO #RenameCommands\r\n\tFROM FinalIndexNames fin\r\n\tWHERE fin.CurrentIndexName <> fin.ProposedName + fin.NumberSuffix; -- Перейменовуємо тільки ті, що відрізняються\r\n\r\n\tDECLARE @cmd NVARCHAR(MAX);\r\n\tDECLARE rename_cursor CURSOR LOCAL FAST_FORWARD FOR\r\n\t\tSELECT RenameCommand FROM #RenameCommands;\r\n\r\n\tOPEN rename_cursor;\r\n\tFETCH NEXT FROM rename_cursor INTO @cmd;\r\n\tWHILE @@FETCH_STATUS = 0\r\n\tBEGIN\r\n\t\tPRINT @cmd; -- Для відладки - показуємо команду перед виконанням\r\n\t\tEXEC sp_executesql @cmd;\r\n\t\tFETCH NEXT FROM rename_cursor INTO @cmd;\r\n\tEND\r\n\tCLOSE rename_cursor;\r\n\tDEALLOCATE rename_cursor;\r\n\tDROP TABLE #RenameCommands;\r\nEND;"
        }
    ]
}